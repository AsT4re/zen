package main

import(
	sfd      "astare/zen/libs/statsfiledatas"
	arrfl    "astare/zen/libs/arrstrflags"
	chart    "github.com/wcharczuk/go-chart"
	errors   "github.com/pkg/errors"
	"fmt"
	"os"
	"flag"
	"bytes"
	"strings"
)

var(
	files arrfl.ArrStrFlags
)

func main() {
	flag.Var(&files, "input", "Files generated by evaldgraph")
	flag.Parse()
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "ERROR: %+v\n", err)
		os.Exit(1)
	}
}

type GraphInfos struct {
	TitleFormat string
	Xleg        string
	Yleg        string
	StatName    string
}

func generateGraphsForStat(infos *GraphInfos, fDatasTab []*sfd.StatsFilesDatas, nbFencesArr []float64, paralConns []float64) error {
	i := 0
	nbFencesAcc := 0
	paralConnsLen := len(paralConns)
	lenFiles := len(fDatasTab)
	for _, nbFences := range nbFencesArr {
		nbFencesAcc += int(nbFences)
		title := fmt.Sprintf(infos.TitleFormat, nbFencesAcc)
		curves := make([]chart.Series, lenFiles)
		datas := make([][]float64, lenFiles)
		for j := 0; j < lenFiles; j++ {
			arr, ok := fDatasTab[j].Stats[infos.StatName]
			if !ok {
				return errors.Errorf("Missing stat '%s' in one file", infos.StatName)
			}
			datas[j] = arr
			filename := files[j]
			ind := strings.LastIndexAny(files[j], "/")
			lenFilename := len(files[j])
			if ind != -1 && ind != lenFilename - 1 {
				filename = filename[ind+1:lenFilename]
			}
			curves[j] = chart.ContinuousSeries{
				Style: chart.StyleShow(),
				XValues: make([]float64, paralConnsLen),
				YValues: make([]float64, paralConnsLen),
				Name: filename,
			}
		}

		for j := 0; j < paralConnsLen; j++ {
			for k := 0; k < lenFiles; k++ {
				curves[k].(chart.ContinuousSeries).XValues[j] = paralConns[j]
				curves[k].(chart.ContinuousSeries).YValues[j] = datas[k][i]
			}
			i++
		}

		graph := chart.Chart{
			Title: title,
			TitleStyle: chart.StyleShow(),
			XAxis: chart.XAxis{
				Name:      infos.Xleg,
				NameStyle: chart.StyleShow(),
				Style:     chart.StyleShow(),
			},
			YAxis: chart.YAxis{
				Name:      infos.Yleg,
				NameStyle: chart.StyleShow(),
				Style:     chart.StyleShow(),
			},
			Background: chart.Style{
				Padding: chart.Box{
					Top:  100,
					Left: 260,
				},
			},
			Series: curves,
		}

		graph.Elements = []chart.Renderable{
			chart.LegendLeft(&graph),
		}

		buffer := bytes.NewBuffer([]byte{})
		if err := graph.Render(chart.PNG, buffer); err != nil {
			return errors.Wrap(err, "Fail to render chart")
		}

		f, err := os.Create(infos.StatName + fmt.Sprintf("-%d.png", nbFencesAcc))
		if err != nil {
			return errors.Wrap(err, "Fail to open file")
		}
		f.Write(buffer.Bytes())
		f.Close()
	}

	return nil
}

func run() error {
	lenFiles := len(files)
	if lenFiles == 0 {
		return errors.New("Missing at least one 'input' file")
	}

	fDatasTab := make([]*sfd.StatsFilesDatas, lenFiles)

	for i, file := range files {
		fDatas := sfd.NewStatsFilesDatas()
		if err := fDatas.Deserialize(file); err != nil {
			return err
		}
		fDatasTab[i] = fDatas
	}

	nbFencesArr, ok := fDatasTab[0].Vars["nb-fences"]
	if !ok {
		return errors.New("Missing variables 'nb-fences'")
	}
	paralConns, ok := fDatasTab[0].Vars["parallel-conns"]
	if !ok {
		return errors.New("Missing variables 'parallel-conns'")
	}

	infos := &GraphInfos{
		StatName: "dg-lat-mean",
		TitleFormat: "DG Reqs latencies means (%d fences)",
		Xleg: "Nb Parallel connections",
		Yleg: "Latency (ms)",
	}
	if err := generateGraphsForStat(infos, fDatasTab, nbFencesArr, paralConns); err != nil {
		return err
	}


	infos.StatName = "dg-lat-perc95"
	infos.TitleFormat = "DG Reqs latencies percentile 95 (%d fences)"
	infos.Xleg = "Nb Parallel connections"
	infos.Yleg = "Latency (ms)"
	if err := generateGraphsForStat(infos, fDatasTab, nbFencesArr, paralConns); err != nil {
		return err
	}

	infos.StatName = "throughput"
	infos.TitleFormat = "Msgs throughput (%d fences)"
	infos.Xleg = "Nb Parallel connections"
	infos.Yleg = "Throughput (nbMessages/sec)"
	if err := generateGraphsForStat(infos, fDatasTab, nbFencesArr, paralConns); err != nil {
		return err
	}

	return nil
}
